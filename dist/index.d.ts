import { ApiBase } from './api-base';
import { Blockchain, BlockchainNetwork, ChainAndAddress, Country, EmailData, MintingData, MintingResult, NftCheckOptions, NftCheckResponse, RedirectEvent, SdkConfiguration, SdkStatus, ServerStatus, VerificationData, VerificationProviderOptions, VerificationStasusByType, VerificationType } from './types';
export { ApiBase, KycDaoApiError } from './api-base';
export { Blockchains, BlockchainNetworks, EvmBlockchainNetworks, NearBlockchainNetworks, KycDaoEnvironments, SolanaBlockchainNetworks, VerificationTypes, } from './constants';
export { ConnectConfig as NearConnectConfig } from 'near-api-js';
export { Blockchain, BlockchainNetwork, BlockchainNetworkConfiguration, ChainAndAddress, Country, EmailData, EvmBlockchainNetwork, MintingData, MintingResult, NearBlockchainNetwork, NetworkAndAddress, NftCheckOptions, NftCheckResponse, PersonaOptions, SdkConfiguration, SdkStatus, SentryConfiguration, ServerStatus, SolanaBlockchainNetwork, TokenMetadata, VerificationData, VerificationProvider, VerificationProviderOptions, VerificationStasusByType, VerificationType, RedirectEvent, } from './types';
export { KycDaoSDKError, ConfigurationError, StatusError, WalletError, TransactionError, InternalError, UnknownError, ErrorCode, WalletErrorCode, StatusErrorCode, TransactionErrorCode, StatusErrors, WalletErrors, TransactionErrors, } from './errors';
export interface KycDaoInitializationResult {
    kycDao: KycDao;
    redirectEvent?: RedirectEvent;
    sdkStatus: SdkStatus;
    transactionUrl?: string;
    mintingResult?: MintingResult;
}
export declare const Countries: Country[];
export declare class KycDao extends ApiBase {
    private demoMode;
    private verificationTypes;
    private blockchainNetworks;
    private networkDetails;
    private getNetworkDetails;
    private sentry;
    private apiStatus?;
    private near?;
    private evmProvider?;
    private solana?;
    private _chainAndAddress?;
    private _mintingState?;
    get sdkStatus(): SdkStatus;
    get connectedWallet(): ChainAndAddress | undefined;
    get walletConnected(): boolean;
    private session?;
    private user?;
    get loggedIn(): boolean;
    get subscribed(): boolean;
    private verificationStatus;
    private isVerifiedForType;
    private getVerificationStatusByType;
    private getSmartContractAddress;
    private getBlockchainAccount;
    private getValidAuthorizationCode;
    private getTx;
    private waitForTransaction;
    private validateBlockchainNetworks;
    private static validateVerificationTypes;
    private static validateEvmProvider;
    private validateEmail;
    private validateVerificationData;
    private syncUserAndSessionWithWallet;
    private refreshSession;
    private initNear;
    private handleNearWalletCallback;
    private handleRedirect;
    private constructor();
    static initialize(config: SdkConfiguration): Promise<KycDaoInitializationResult>;
    getServerStatus(): Promise<ServerStatus>;
    private getChainAndAddressForNftCheck;
    private getRpcProviderForWallet;
    private checkValidNft;
    hasValidNft(verificationType: VerificationType, options?: NftCheckOptions): Promise<boolean>;
    getValidNfts(verificationType: VerificationType, options?: NftCheckOptions): Promise<NftCheckResponse>;
    checkVerifiedNetworks(verificationType: VerificationType, options?: NftCheckOptions): Promise<NftCheckResponse[]>;
    private switchOrAddNetworkChecked;
    private isUserRejectError;
    private ensureValidProviderNetwork;
    checkProviderNetwork(): Promise<BlockchainNetwork>;
    switchProviderNetwork(blockchainNetwork: BlockchainNetwork): Promise<void>;
    connectWallet(blockchain: Blockchain): Promise<void>;
    disconnectWallet(): Promise<void>;
    registerOrLogin(): Promise<void>;
    updateEmail(email: string): Promise<void>;
    checkEmailConfirmed(): Promise<EmailData>;
    resendEmailConfirmationCode(): Promise<void>;
    private loadPersona;
    startVerification(verificationData: VerificationData, providerOptions?: VerificationProviderOptions): Promise<void>;
    checkVerificationStatus(): Promise<VerificationStasusByType>;
    getNftImageUrl(): string;
    regenerateNftImage(): Promise<void>;
    getNftImageOptions(): Promise<{
        [imageId: string]: string;
    }>;
    regenerateNftImageOptions(): Promise<{
        [imageId: string]: string;
    }>;
    private authorizeMinting;
    private mint;
    startMinting(mintingData: MintingData): Promise<MintingResult | undefined>;
}
